class HexenRPGHud : BaseStatusBar
{
    HUDFont mHUDFont;
	HUDFont mIndexFont;
	HUDFont mNumHud;
    HUDFont smallfont;
	InventoryBarState diparms;
	InventoryBarState diparms_sbar;
    DynamicValueInterpolator mHealthInterpolator, mManaInterpolator, mStaminaInterpolator;
    Array<string> keys;

    override void Init()
	{
		Super.Init();
		SetSize(44, 320, 200);

		// Create the font used for the fullscreen HUD
		Font fnt = "HUDFONT_RAVEN";
		mHUDFont = HUDFont.Create(fnt, fnt.GetCharWidth("0") + 1, Mono_CellLeft, 1, 1);
		fnt = "INDEXFONT_RAVEN";
		mIndexFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft);

        fnt = "indexfont";
		mNumHud = HUDFont.Create(fnt, fnt.GetCharWidth("0"), Mono_CellLeft, 0, 0);

        fnt = "SMALLFONT";
        smallfont = HUDFont.Create(fnt);

		diparms = InventoryBarState.Create(mIndexFont);
		diparms_sbar = InventoryBarState.CreateNoBox(mIndexFont, boxsize:(31, 31), arrowoffs:(0,-10));

		mHealthInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
        mManaInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 8);
        mStaminaInterpolator = DynamicValueInterpolator.Create(0, 0.25, 1, 8);


        // key binds


        keys.push(Bindings.namekeys(Bindings.GetKeysForCommand("+attack"),0));
        keys.push(Bindings.namekeys(Bindings.GetKeysForCommand("+altattack"),0));
        keys.push(Bindings.namekeys(Bindings.GetKeysForCommand("+reload"),0));
        keys.push(Bindings.namekeys(Bindings.GetKeysForCommand("+zoom"),0));


        for(int i = 0;i<4;i++)
        {
            if(keys[i].Length() > 1)
                keys[i] = keys[i].left(1)..keys[i].mid(keys[i].Length()-1,1);
        }


	}


	override void Draw (int state, double TicFrac)
	{
        completeborder = true;
		Super.Draw (state, TicFrac);
        if (state == HUD_StatusBar)
		{
			//BeginStatusBar();
			//DrawMainBar(TicFrac);
            //drawfullscreenstuff();
		}
		else if (state == HUD_Fullscreen)
		{
			BeginHUD();
			DrawFullScreenStuff ();
		}
	}

    void DrawMainBar(double TicFrac) {
        DrawImage("HBAR", (-16, 135), DI_ITEM_OFFSETS|DI_ITEM_CENTER);
	}

    override void NewGame ()
	{
		Super.NewGame();
		mHealthInterpolator.Reset (0);
        mManaInterpolator.Reset (0);
        mStaminaInterpolator.Reset (0);
    }

    override void Tick()
	{
		Super.Tick();
		mHealthInterpolator.Update(CPlayer.health);
        Inventory man = CPlayer.mo.FindInventory("Mana1"),
                stam = CPlayer.mo.FindInventory("Mana2");
		if (man) mManaInterpolator.Update(man.Amount);
        if (stam) mStaminaInterpolator.Update(stam.Amount);

    }

    void DrawOrbs()
    {
        drawbar("horb","norb",mhealthinterpolator.getvalue(),100,(-129,-45),0,3,DI_ITEM_OFFSETS|DI_SCREEN_CENTER_BOTTOM);
        drawbar("morb","norb2",mManaInterpolator.getvalue(),200,(79,-45),0,3,DI_ITEM_OFFSETS|DI_SCREEN_CENTER_BOTTOM);
        drawbar("sorb","norb2",mStaminaInterpolator.getvalue(),200,(107,-45),0,3,DI_ITEM_OFFSETS|DI_SCREEN_CENTER_BOTTOM);
        DrawImage("HBAR", (-176, -65), DI_ITEM_OFFSETS|DI_SCREEN_CENTER_BOTTOM);
    }

    void drawAbility(string Icon, Vector2 Location,int minMana, int minStam, int keybind)
    {
        if(CPLAYER.cmd.Buttons & keybind)
        {
            Location = (Location.X-1, Location.Y-1);
        }
        let drawflags = DI_ITEM_OFFSETS|DI_SCREEN_CENTER_BOTTOM;

        if(CPlayer.mo.findinventory("mana1").amount < minMana
            || Cplayer.mo.findInventory("mana2").amount < minStam)
        {
            drawflags = drawflags|DI_DIM;
        }
        DrawImage(Icon, Location, drawflags);
    }

    // returns true if ticsleft < 5
    void drawCooldown(string cooldownPowerup, Vector2 radMaskPos, Vector2 numPos,Vector2 FlashLocation = (0,0),string childPowerUp = "")
    {
        // mismatched aura cooldown takes priority (have aura-length cooldown but aura is off)
        if(CPLAYER.mo.findinventory(childPowerUp))
            cooldownPowerup = childPowerUp;

        if(CPLAYER.mo.findinventory(cooldownPowerup))
        {
            int ticsleft,maxduration;
            [ticsleft,maxduration] = CPLAYER.mo.geteffectticsforitem(cooldownPowerup.mid(5));
            drawRadialMask(ticsleft*100 / maxduration ,radMaskPos);
            let secondsleft = Formatnumber((ticsleft+35)/35);
            if(ticsleft < 30 && FlashLocation != (0,0))
            {
                let alpha = (ticsleft>=3) ? (3/ticsleft) : ticsleft/3;
                readyFlash(FlashLocation,alpha-0.55);
            }


            DrawString(mNumHud, secondsleft, numPos,DI_ITEM_OFFSETS|DI_SCREEN_CENTER_BOTTOM);
        }
    }
    void readyFlash(Vector2 Location, float flashAlpha)
    {
        DrawImage("flash", Location, DI_ITEM_OFFSETS|DI_SCREEN_CENTER_BOTTOM,flashAlpha);
    }

	protected void DrawFullScreenStuff ()
	{
        DrawOrbs();

		// hud numbers
        // should make these optional with a cvar or somehting
		DrawString(mNumHud, FormatNumber(mHealthInterpolator.GetValue()), (-115, -20),DI_ITEM_OFFSETS|DI_SCREEN_CENTER_BOTTOM);
        DrawString(mNumHud, FormatNumber(mManaInterpolator.GetValue()), (90, -20), DI_ITEM_OFFSETS|DI_SCREEN_CENTER_BOTTOM);
        DrawString(mNumHud, FormatNumber(mStaminaInterpolator.GetValue()), (110, -20), DI_ITEM_OFFSETS|DI_SCREEN_CENTER_BOTTOM);

        let wep = Weapon(CPlayer.ReadyWeapon);
		if (wep)
		{
            if(wep.gettag() == "Mace of Attrition")
            {
                DrawAbility("PENCA0", (-72.8,-35), 0 , 5, BT_ATTACK);
                DrawAbility("SHOVA0", (-35.25,-35), 0 , 13, BT_ALTATTACK);
                DrawCoolDown("PowerShoveCooldown", (-35.25,-35), (-9.2, -16),(-35.25,-35));
                if(CPLAYER.mo.findinventory("FixationAura"))
                {
                    DrawAbility("PTRAA0", (1.95,-35), 80, 0, BT_RELOAD);
                    DrawCooldown("powerPetrifyCooldown",(39,-35),(28, -16),(1.95,-35),"powerPetrifyCooldownShort");
                }
                else
                {
                    DrawAbility("PTRIA0", (1.95,-35), 40, 0, BT_RELOAD);
                    DrawCooldown("powerPetrifyCooldownshort",(39,-35),(28, -16),(1.95,-35),"powerPetrifyCooldown");
                }
                DrawAbility("PAURA0",(39,-35),0,0, BT_ZOOM);
            }
        }
        // Draw ability keybinds
        let drawflags = DI_ITEM_OFFSETS|DI_SCREEN_CENTER_BOTTOM;
        DrawString(smallfont,keys[0],(-72.8,-35),drawflags);
        DrawString(smallfont,keys[1],(-35.25,-35),drawflags);
        DrawString(smallfont,keys[2],(1.95,-35),drawflags);
        DrawString(smallfont,keys[3],(39,-35),drawflags);

	}
    void drawRadialMask(float percentage, Vector2 pos)
    {
        let angle = percentage * 3.6;
        let tex = texman.checkfortexture("cdown");
        if(angle > 0)
        {
            let tr = calcTriangle(angle>45?45:angle, false, pos);
            Screen.DrawShape(tex, false,tr);
        }
        if(angle > 45)
        {
           let tr = calcTriangle(angle>90?90:angle, true, pos);
           Screen.DrawShape(tex, false,tr);
        }
        if(angle > 90)
        {
           let tr = calcTriangle(angle>135?135:angle, false, pos);
           Screen.DrawShape(tex, false,tr);
        }
        if(angle > 135)
        {
           let tr = calcTriangle(angle>180?180:angle, true, pos);
           Screen.DrawShape(tex, false,tr);
        }
        if(angle > 180)
        {
           let tr = calcTriangle(angle>225?225:angle, false, pos);
           Screen.DrawShape(tex, false,tr);
        }
        if(angle > 225)
        {
           let tr = calcTriangle(angle>270?270:angle, true, pos);
           Screen.DrawShape(tex, false,tr);
        }
        if(angle > 270)
        {
           let tr = calcTriangle(angle>315?315:angle, false, pos);
           Screen.DrawShape(tex, false,tr);
        }
        if(angle > 315)
        {
           let tr = calcTriangle(angle>360?360:angle, true, pos);
           Screen.DrawShape(tex, false,tr);
        }
    }

    Shape2D calcTriangle(float angle, bool flip, Vector2 pos)
    {
        let tr = new("Shape2D");
        tr.pushvertex((0,0)); //always have one vertex in origin
        tr.pushvertex((flip?1:0,-1));
        let rotation = flip?45:0;

        let factor = angle/45;
        for(int i = 1;i<factor; i++)
        {
            rotation +=45;
            angle -=45;
        }

        if(flip)
            tr.pushvertex((Angle>45?0:1-tan(Angle) ,-1));
        else
            tr.pushvertex((Angle>45?-1:-tan(Angle) ,-1));

        tr.pushcoord((0,0));
        tr.pushcoord((0,1));
        tr.pushcoord((1,1));

        tr.pushtriangle(0,1,2);

        let tran = new("Shape2DTransform");
        tran.scale((34,34));
        tran.rotate(-rotation);
        tran.Translate(( (Screen.getWidth()/2)+pos.X, Screen.getHeight()+pos.Y-16));

        tr.setTransform(tran);
        return tr;
    }

}

